// Code generated by https://github.com/GoComply/metaschema; DO NOT EDIT.
// Multiplexers are indirect models needed for serialization/deserialization
// as json and xml files differ materially in their structure.
package system_security_plan

import (
	"bytes"
	"encoding/json"
)

type AnnotationMultiplexer []Annotation

func (mplex *AnnotationMultiplexer) UnmarshalJSON(b []byte) error {
	var l []Annotation
	switch b[0] {
	case '{':
		var singleton Annotation
		if err := json.Unmarshal(b, &singleton); err != nil {
			return err
		}
		l = append(l, singleton)
	default:
		if err := json.Unmarshal(b, &l); err != nil {
			return err
		}
	}
	(*mplex) = l
	return nil
}

func (mplex *AnnotationMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'['})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte(']'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type ByComponentMultiplexer []ByComponent

func (mplex *ByComponentMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]ByComponent
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]ByComponent, 0, len(insideMap))
	for k, v := range insideMap {
		v.ComponentUuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *ByComponentMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.ComponentUuid + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type ComponentMultiplexer []Component

func (mplex *ComponentMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]Component
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]Component, 0, len(insideMap))
	for k, v := range insideMap {
		v.Uuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *ComponentMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.Uuid + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type DiagramMultiplexer []Diagram

func (mplex *DiagramMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]Diagram
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]Diagram, 0, len(insideMap))
	for k, v := range insideMap {
		v.Uuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *DiagramMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.Uuid + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type ImplementedComponentMultiplexer []ImplementedComponent

func (mplex *ImplementedComponentMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]ImplementedComponent
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]ImplementedComponent, 0, len(insideMap))
	for k, v := range insideMap {
		v.ComponentUuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *ImplementedComponentMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.ComponentUuid + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type InheritedMultiplexer []Inherited

func (mplex *InheritedMultiplexer) UnmarshalJSON(b []byte) error {
	var l []Inherited
	switch b[0] {
	case '{':
		var singleton Inherited
		if err := json.Unmarshal(b, &singleton); err != nil {
			return err
		}
		l = append(l, singleton)
	default:
		if err := json.Unmarshal(b, &l); err != nil {
			return err
		}
	}
	(*mplex) = l
	return nil
}

func (mplex *InheritedMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'['})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte(']'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type InventoryItemMultiplexer []InventoryItem

func (mplex *InventoryItemMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]InventoryItem
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]InventoryItem, 0, len(insideMap))
	for k, v := range insideMap {
		v.Uuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *InventoryItemMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.Uuid + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type ProvidedMultiplexer []Provided

func (mplex *ProvidedMultiplexer) UnmarshalJSON(b []byte) error {
	var l []Provided
	switch b[0] {
	case '{':
		var singleton Provided
		if err := json.Unmarshal(b, &singleton); err != nil {
			return err
		}
		l = append(l, singleton)
	default:
		if err := json.Unmarshal(b, &l); err != nil {
			return err
		}
	}
	(*mplex) = l
	return nil
}

func (mplex *ProvidedMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'['})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte(']'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type ResponsibilityMultiplexer []Responsibility

func (mplex *ResponsibilityMultiplexer) UnmarshalJSON(b []byte) error {
	var l []Responsibility
	switch b[0] {
	case '{':
		var singleton Responsibility
		if err := json.Unmarshal(b, &singleton); err != nil {
			return err
		}
		l = append(l, singleton)
	default:
		if err := json.Unmarshal(b, &l); err != nil {
			return err
		}
	}
	(*mplex) = l
	return nil
}

func (mplex *ResponsibilityMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'['})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte(']'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type SatisfiedMultiplexer []Satisfied

func (mplex *SatisfiedMultiplexer) UnmarshalJSON(b []byte) error {
	var l []Satisfied
	switch b[0] {
	case '{':
		var singleton Satisfied
		if err := json.Unmarshal(b, &singleton); err != nil {
			return err
		}
		l = append(l, singleton)
	default:
		if err := json.Unmarshal(b, &l); err != nil {
			return err
		}
	}
	(*mplex) = l
	return nil
}

func (mplex *SatisfiedMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'['})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte(']'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type StatementMultiplexer []Statement

func (mplex *StatementMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]Statement
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]Statement, 0, len(insideMap))
	for k, v := range insideMap {
		v.StatementId = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *StatementMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.StatementId + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type UserMultiplexer []User

func (mplex *UserMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]User
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]User, 0, len(insideMap))
	for k, v := range insideMap {
		v.Uuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *UserMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.Uuid + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}
