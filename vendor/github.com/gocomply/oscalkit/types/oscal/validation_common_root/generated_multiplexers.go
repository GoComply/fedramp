// Code generated by https://github.com/GoComply/metaschema; DO NOT EDIT.
// Multiplexers are indirect models needed for serialization/deserialization
// as json and xml files differ materially in their structure.
package validation_common_root

import (
	"bytes"
	"encoding/json"
)

type IncorporatesComponentMultiplexer []IncorporatesComponent

func (mplex *IncorporatesComponentMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]IncorporatesComponent
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]IncorporatesComponent, 0, len(insideMap))
	for k, v := range insideMap {
		v.ComponentUuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *IncorporatesComponentMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.ComponentUuid + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type OnlyStatementMultiplexer []OnlyStatement

func (mplex *OnlyStatementMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]OnlyStatement
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]OnlyStatement, 0, len(insideMap))
	for k, v := range insideMap {
		v.StatementId = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *OnlyStatementMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.StatementId + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type ResponsibleRoleMultiplexer []ResponsibleRole

func (mplex *ResponsibleRoleMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]ResponsibleRole
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]ResponsibleRole, 0, len(insideMap))
	for k, v := range insideMap {
		v.RoleId = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *ResponsibleRoleMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.RoleId + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}

type SetParameterMultiplexer []SetParameter

func (mplex *SetParameterMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]SetParameter
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]SetParameter, 0, len(insideMap))
	for k, v := range insideMap {
		v.ParamId = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

func (mplex *SetParameterMultiplexer) MarshalJSON() ([]byte, error) {
	js := bytes.NewBuffer([]byte{'{'})

	empty := true
	for _, v := range *mplex {
		if !empty {
			if err := js.WriteByte(','); err != nil {
				return []byte{}, err
			}
		}
		empty = false

		if _, err := js.WriteString("\"" + v.ParamId + "\":"); err != nil {
			return []byte{}, err
		}

		text, err := json.Marshal(v)
		if err != nil {
			return []byte{}, err
		}
		if _, err = js.Write(text); err != nil {
			return []byte{}, err
		}
	}
	if err := js.WriteByte('}'); err != nil {
		return []byte{}, err
	}
	return js.Bytes(), nil
}
