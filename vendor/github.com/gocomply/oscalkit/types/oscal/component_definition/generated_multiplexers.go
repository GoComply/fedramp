// Code generated by https://github.com/GoComply/metaschema; DO NOT EDIT.
// Multiplexers are indirect models needed for serialization/deserialization
// as json and xml files differ materially in their structure.
package component_definition

import (
	"encoding/json"
)

type AnnotationMultiplexer []Annotation

func (mplex *AnnotationMultiplexer) UnmarshalJSON(b []byte) error {
	var l []Annotation
	switch b[0] {
	case '{':
		var singleton Annotation
		if err := json.Unmarshal(b, &singleton); err != nil {
			return err
		}
		l = append(l, singleton)
	default:
		if err := json.Unmarshal(b, &l); err != nil {
			return err
		}
	}
	(*mplex) = l
	return nil
}

type CapabilityMultiplexer []Capability

func (mplex *CapabilityMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]Capability
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]Capability, 0, len(insideMap))
	for k, v := range insideMap {
		v.Uuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

type ComponentMultiplexer []Component

func (mplex *ComponentMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]Component
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]Component, 0, len(insideMap))
	for k, v := range insideMap {
		v.Uuid = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}

type StatementMultiplexer []Statement

func (mplex *StatementMultiplexer) UnmarshalJSON(b []byte) error {
	var insideMap map[string]Statement
	if err := json.Unmarshal(b, &insideMap); err != nil {
		return err
	}

	l := make([]Statement, 0, len(insideMap))
	for k, v := range insideMap {
		v.StatementId = k
		l = append(l, v)
	}
	(*mplex) = l
	return nil
}
